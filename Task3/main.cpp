#include <iostream>#include <mpi.h>#define Matrix double*enum COORDS {    X,    Y};enum SIZE_MATRIX {    n1 = 4,    n2 = 4,    n3 = 2,};enum {    NUMBER_DIMS = 2,    ROOT = 0,    ZERO_VALUE = 0};void FreeMatrix(Matrix m1, Matrix m2, Matrix m3) {    free(m1);    free(m2);    free(m3);}void FreeComm(MPI_Comm* comm1, MPI_Comm* comm2, MPI_Comm* comm3) {    MPI_Comm_free(comm1);    MPI_Comm_free(comm2);    MPI_Comm_free(comm3);}void PrintMatrix(Matrix matrix, int sizeRow, int sizeColumn) {      for (int i = 0; i < sizeRow; ++i) {          for (int j = 0; j < sizeColumn; ++j) {              std::cout << matrix[i*sizeColumn+j] << " ";          }          std::cout << std::endl;      }}Matrix GenerateMatrix(int sizeRow, int sizeColumn) {    Matrix matrix = new double[sizeColumn * sizeRow];    for (int i = 0; i < sizeRow; ++i) {        for (int j = 0; j < sizeColumn; ++j) {            matrix[i * sizeColumn + j] = static_cast<double>(i * sizeColumn + j);        }    }    return matrix;}void CreationCommunicators(int size, int rank, int coords[], int dims[],                           MPI_Comm* comm2d, MPI_Comm* commColumn, MPI_Comm* commRow) {    MPI_Dims_create(size, NUMBER_DIMS, dims);    int periods[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    int reorder = 1;    MPI_Cart_create(MPI_COMM_WORLD, NUMBER_DIMS, dims, periods, reorder, comm2d);    MPI_Cart_coords(*comm2d, rank, NUMBER_DIMS, coords);    MPI_Comm_split(*comm2d, X, Y, commRow);    MPI_Comm_split(*comm2d, Y, X, commColumn);}void MatrixMultiplication(Matrix matrixFirst, Matrix matrixSecond, Matrix result) {    for(int i = 0; i < SIZE_MATRIX::n1; ++i) {        for(int j = 0; j < SIZE_MATRIX::n2; ++j) {            result[i * SIZE_MATRIX::n3] = 0;            for(int k = 0; k < SIZE_MATRIX::n3; ++k) {                result[i * SIZE_MATRIX::n3 + k] += matrixFirst[SIZE_MATRIX::] * matrixSecond[];            }        }    }}bool CheckResult(Matrix result, Matrix rightDecision, int row, int column) {    for(int i = 0; i < row; ++i) {        for(int j = 0; j < column; ++j) {            if(result[i*column+j] != rightDecision[i*column+j])                return false;        }    }    return true;}void  SplitMatrixVertically(Matrix matrix, Matrix partMatrix,                            int sizeRow, int sizeColumn, MPI_Comm commColumn) { }void distributionMatrixIntoNodes(Matrix matrixA, Matrix matrixB,                                 Matrix partMatrixA, Matrix partMatrixB,                                 MPI_Comm commColumn, MPI_Comm commRow,                                 int dims[], int coords[]) {    if(coords[COORDS::Y] == ZERO_VALUE) {        MPI_Scatter(matrixA, (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, partMatrixA,                    (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, ROOT, commColumn);    }    if(coords[COORDS::X] == ZERO_VALUE) {        MPI_Datatype vectorType, newType;        MPI_Type_vector(SIZE_MATRIX::n2, SIZE_MATRIX::n3 / dims[COORDS::Y], n3, MPI_DOUBLE, &vectorType);        MPI_Type_commit(&vectorType);        MPI_Type_create_resized(vectorType, ZERO_VALUE, SIZE_MATRIX::n3 / dims[COORDS::Y] * sizeof(double), &newType);        MPI_Type_commit(&newType);        MPI_Scatter(matrixB, 1, newType, partMatrixB,                    (SIZE_MATRIX::n3 * SIZE_MATRIX::n2) / dims[COORDS::Y], MPI_DOUBLE, ROOT, commRow);    }    MPI_Bcast(partMatrixA, (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, ROOT, commColumn);    MPI_Bcast(partMatrixB, (SIZE_MATRIX::n3 * SIZE_MATRIX::n2) / dims[COORDS::Y], MPI_DOUBLE, ROOT, commRow);}void RunMultiplicationMatrix(int rank, int cntProcess) {    Matrix A = NULL; Matrix B = NULL; Matrix C = NULL;    if(rank == ROOT) {        A = GenerateMatrix(SIZE_MATRIX::n1, SIZE_MATRIX::n2);        B = GenerateMatrix(SIZE_MATRIX::n2, SIZE_MATRIX::n3);        C = new double[SIZE_MATRIX::n1 * SIZE_MATRIX::n3];    }    MPI_Comm comm2d, commColumn, commRow;    int coords[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    int dims[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    CreationCommunicators(cntProcess, rank, coords, dims, &comm2d, &commColumn, &commRow);    Matrix partMatrixA = new double[(SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X]];    Matrix partMatrixB = new double[(SIZE_MATRIX::n2 * SIZE_MATRIX::n3) / dims[COORDS::Y]];    Matrix partMatrixC = new double[(SIZE_MATRIX::n2 * SIZE_MATRIX::n3) / (dims[COORDS::X] * dims[COORDS::Y])];    distributionMatrixIntoNodes(A, B,                                partMatrixA, partMatrixB,                                commColumn, commRow,                                dims, coords);    FreeMatrix(partMatrixA, partMatrixB, partMatrixC);    if(rank == ROOT) FreeMatrix(A, B, C);    FreeComm(&comm2d, &commColumn, &commRow);}int main(int argc, char** argv) {    MPI_Init(&argc, &argv);    double startTime = MPI_Wtime();    int rank = ZERO_VALUE, cntProcess = ZERO_VALUE;    MPI_Comm_rank(MPI_COMM_WORLD, &rank);    MPI_Comm_size(MPI_COMM_WORLD, &cntProcess);    RunMultiplicationMatrix(rank, cntProcess);    double endTime = MPI_Wtime();    if(rank == ROOT) {        std::cout << "\nTIME: " << endTime - startTime << std::endl;    }    MPI_Finalize();    return EXIT_SUCCESS;}   // . .    // . .    // . .    // . .    // .    // .    //  1   2    //  5   6    //  9   10    //  13  14