#include <iostream>#include <mpi.h>#define Matrix double*enum COORDS {    X,    Y};enum SIZE_MATRIX {    n1 = 6,    n2 = 6,    n3 = 4};enum {    NUMBER_DIMS = 2,    ROOT = 0,    ZERO_VALUE = 0};void FreeMatrix(Matrix m1, Matrix m2, Matrix m3) {    free(m1);    free(m2);    free(m3);}void FreeComm(MPI_Comm* comm1, MPI_Comm* comm2, MPI_Comm* comm3) {    MPI_Comm_free(comm1);    MPI_Comm_free(comm2);    MPI_Comm_free(comm3);}void PrintMatrix(const Matrix matrix, const int sizeRow, const int sizeColumn) {      for (int i = 0; i < sizeRow; ++i) {          for (int j = 0; j < sizeColumn; ++j) {              std::cout << matrix[i*sizeColumn+j] << " ";          }          std::cout << std::endl;      }}Matrix GenerateMatrix(const int sizeRow, const int sizeColumn) {    Matrix matrix = new double[sizeColumn * sizeRow];    for (int i = 0; i < sizeRow; ++i) {        for (int j = 0; j < sizeColumn; ++j) {            matrix[i * sizeColumn + j] = static_cast<double>(i * sizeColumn + j + 1);        }    }    return matrix;}void CreationCommunicators(const int size, const int rank, int coords[], int dims[],                           MPI_Comm* comm2d, MPI_Comm* commColumn, MPI_Comm* commRow) {    MPI_Dims_create(size, NUMBER_DIMS, dims);    int periods[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    int reorder = 1;    MPI_Cart_create(MPI_COMM_WORLD, NUMBER_DIMS, dims, periods, reorder, comm2d);    MPI_Cart_coords(*comm2d, rank, NUMBER_DIMS, coords);    int coordsRow[] = {COORDS::X, COORDS::Y};    int coordsColumn[] = {COORDS::Y, COORDS::X};    MPI_Cart_sub(*comm2d, coordsRow, commRow);    MPI_Cart_sub(*comm2d, coordsColumn, commColumn);}void CreateMatrixCFromSeparatedBlock(const Matrix partC, Matrix C,                                     const int sizePartRow, const int sizePartColumn,                                     const int countColumn, const MPI_Comm comm2d) {    MPI_Datatype vectorType, newType;    MPI_Type_vector(sizePartColumn, countColumn, sizePartRow, MPI_DOUBLE, &vectorType);    MPI_Type_commit(&vectorType);    MPI_Type_create_resized(vectorType, ZERO_VALUE, countColumn * sizeof(double), &newType);    MPI_Type_commit(&newType);    MPI_Gather(partC, 1, newType, C, sizePartColumn * sizePartRow, MPI_DOUBLE, ROOT, comm2d);}void MatrixMultiplication(const Matrix matrixFirst, const Matrix matrixSecond, Matrix result,                          const int N, const int M, const int K) {      for(int i = 0; i < N; ++i) {        for(int j = 0; j < K; ++j) {            result[i * K + j] = 0;            for(int k = 0; k < M; ++k) {                 result[i * K + j] += matrixFirst[i * M + k] * matrixSecond[k * K + j];            }        }    }}bool CheckResult(const Matrix result, const Matrix rightDecision,                 const int row, const int column) {    for(int i = 0; i < row; ++i) {        for(int j = 0; j < column; ++j) {            if(result[i*column+j] != rightDecision[i*column+j])                return false;        }    }    return true;}void SplitMatrixVertically(Matrix matrix, Matrix partMatrix,                           int sizeRow, int sizeColumn, MPI_Comm commColumn) { }void DistributionMatrixIntoNodes(const Matrix matrixA, const Matrix matrixB,                                 Matrix partMatrixA, Matrix partMatrixB,                                 const MPI_Comm commColumn, const MPI_Comm commRow,                                 int dims[], int coords[]) {    if(coords[COORDS::Y] == ZERO_VALUE) {        MPI_Scatter(matrixA, (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, partMatrixA,                    (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, ROOT, commColumn);    }    if(coords[COORDS::X] == ZERO_VALUE) {        MPI_Datatype vectorType, newType;        MPI_Type_vector(SIZE_MATRIX::n2, SIZE_MATRIX::n3 / dims[COORDS::Y], n3, MPI_DOUBLE, &vectorType);        MPI_Type_commit(&vectorType);        MPI_Type_create_resized(vectorType, ZERO_VALUE, SIZE_MATRIX::n3 / dims[COORDS::Y] * sizeof(double), &newType);        MPI_Type_commit(&newType);        MPI_Scatter(matrixB, 1, newType, partMatrixB,                    (SIZE_MATRIX::n3 * SIZE_MATRIX::n2) / dims[COORDS::Y], MPI_DOUBLE, ROOT, commRow);    }    MPI_Bcast(partMatrixA, (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X], MPI_DOUBLE, ROOT, commRow);    MPI_Bcast(partMatrixB, (SIZE_MATRIX::n3 * SIZE_MATRIX::n2) / dims[COORDS::Y], MPI_DOUBLE, ROOT, commColumn);}void RunMultiplicationMatrix(const int rank, const int cntProcess) {    Matrix A = NULL; Matrix B = NULL; Matrix C = NULL;    if(rank == ROOT) {        A = GenerateMatrix(SIZE_MATRIX::n1, SIZE_MATRIX::n2);        B = GenerateMatrix(SIZE_MATRIX::n2, SIZE_MATRIX::n3);        C = new double[SIZE_MATRIX::n1 * SIZE_MATRIX::n3];        MatrixMultiplication(A, B, C, n1, n2, n3);    }    MPI_Comm comm2d, commColumn, commRow;    int coords[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    int dims[NUMBER_DIMS] = {ZERO_VALUE, ZERO_VALUE};    CreationCommunicators(cntProcess, rank, coords, dims, &comm2d, &commColumn, &commRow);    int sizePartMatrixA = (SIZE_MATRIX::n1 * SIZE_MATRIX::n2) / dims[COORDS::X];    int sizePartMatrixB = (SIZE_MATRIX::n2 * SIZE_MATRIX::n3) / dims[COORDS::Y];    int sizePartMatrixC = (SIZE_MATRIX::n2 * SIZE_MATRIX::n3) / (dims[COORDS::X] * dims[COORDS::Y]);    Matrix partMatrixA = new double[sizePartMatrixA];    Matrix partMatrixB = new double[sizePartMatrixB];    Matrix partMatrixC = new double[sizePartMatrixC];    DistributionMatrixIntoNodes(A, B,                                partMatrixA, partMatrixB,                                commColumn, commRow,                                dims, coords);    MatrixMultiplication(partMatrixA, partMatrixB, partMatrixC,                         SIZE_MATRIX::n1 / dims[COORDS::X],                         SIZE_MATRIX::n2,                         SIZE_MATRIX::n3 / dims[COORDS::Y]);    CreateMatrixCFromSeparatedBlock(partMatrixC,                                    C,                                    SIZE_MATRIX::n3 / dims[COORDS::Y],                                    SIZE_MATRIX::n2 / dims[COORDS::X],                                    n3,                                    comm2d);    if(rank == ROOT) {       PrintMatrix(C, n1, n3);    }    FreeMatrix(partMatrixA, partMatrixB, partMatrixC);    if(rank == ROOT) FreeMatrix(A, B, C);    FreeComm(&comm2d, &commColumn, &commRow);}int main(int argc, char** argv) {    MPI_Init(&argc, &argv);    double startTime = MPI_Wtime();    int rank = ZERO_VALUE, cntProcess = ZERO_VALUE;    MPI_Comm_rank(MPI_COMM_WORLD, &rank);    MPI_Comm_size(MPI_COMM_WORLD, &cntProcess);    RunMultiplicationMatrix(rank, cntProcess);    double endTime = MPI_Wtime();    if(rank == ROOT) {        std::cout << "\nTIME: " << endTime - startTime << std::endl;    }    MPI_Finalize();    return EXIT_SUCCESS;}